---
title: 全栈工程师养成记录9
url: 217.html
id: 217
categories:
  - Bob
  - 技术
date: 2017-03-22 14:04:09
tags:
---

最近的几天忙于陪护Fiona，一直也没有时间、没心情去研究数据采集端的问题。 初步想法是和现地采集器通信方式交互数据，可以选择的模式有共享内存、tcp/ip报文等通信方式。采集到的数据定期更新到server端，在这个过程中一度想用C/C++直接做个小程序操作mongodb得了，最后看了看mongodb那个繁琐的（实际还可以，可能是最近对C++有点排斥，呵呵）驱动库，还得连接boost什么的，算了，不用了。 那剩下的选择就不多了，想过用node，可又觉得不太合适。 今天上午仔细研究了一下使用go的可行性，发现用go做这个小终端挺合适，以前学习了好几次go语言，都没啥实用项目，做的小程序都是例子一类的。这回就来个实际操作吧。 定下来go，发现不用自己用http库自己解析RESTFUL api了，有一个go的库go-resty直接已经做好了，这个方便多了，直接用就可以了。 类似的Get，Put方法都很简单 _resp, err := resty.R().Get("http://localhost:3000/ghs/150001000001")_ _fmt.Printf("\\nError: %v", err)_ _fmt.Printf("\\nResponse Status Code: %v", resp.StatusCode())_ _fmt.Printf("\\nResponse Status: %v", resp.Status())_ _fmt.Printf("\\nResponse Time: %v", resp.Time())_ _fmt.Printf("\\nResponse Recevied At: %v", resp.ReceivedAt())_ _var gh GreenHouse_ _err = json.Unmarshal(resp.Body(), &gh)_ _if err != nil {_ _panic(err)_ _}_ _fmt.Println("")_ _fmt.Println("id:", gh.ID)_ _fmt.Println("ghName:", gh.GhName)_ _fmt.Println("UID:", gh.UID)_ _put_resp, err1 := resty.R()._ _SetBody(GreenHouse{Hum1: 11.23, Hum2: 12})._ _Put("http://localhost:3000/ghs/150001000001")_ _fmt.Printf("\\nError: %v", err1)_ _fmt.Printf("\\nResponse Status Code: %v", put_resp.StatusCode())_ 这么短短几行代码基本搞定了。 另外这个[https://mholt.github.io/json-to-go/](https://mholt.github.io/json-to-go/)网站很好，json到go结构体，非常方便，省了很多事。 基本上剩下的就是收集数据，维护内存数据，然后定期更新server端数据，同时还要有个定时读取server端命令的coroutine，收到命令后发给采集器。